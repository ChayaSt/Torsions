"""
Toy model of 4 carbons to test torsionfit

"""

from parmed.charmm import CharmmParameterSet, CharmmPsfFile
import StringIO
import simtk.openmm.app as app
import simtk.openmm as mm
import simtk.unit as units
import mdtraj as md
import numpy as np
import torsionfit.TorsionScanSet as ScanSet
import torsionfit.TorsionFitModel as Model

pdb = """
ATOM      1  C1  TOY    1       0.000  -1.437  -0.526  1.00  0.00
ATOM      2  C2  TOY    1       0.000   0.000   0.000  1.00  0.00
ATOM      3  C3  TOY    1       0.000   0.000   1.530  1.00  0.00
ATOM      4  C4  TOY    1       0.344   1.395   2.056  1.00  0.00
TER
"""

psf = """
PSF EXT

       3 !NTITLE
 REMARKS original generated structure x-plor psf file
 REMARKS topology toy.str
 REMARKS segment BUTA { first NONE; last NONE; auto none  }

       4 !NATOM
         1 BUTA     1        TOY      C1       CG331    0.000000       12.0110           0
         2 BUTA     1        TOY      C2       CG321    0.000000       12.0110           0
         3 BUTA     1        TOY      C3       CG321    0.000000       12.0110           0
         4 BUTA     1        TOY      C4       CG331    0.000000       12.0110           0

       3 !NBOND: bonds
         1         2         3         2         3         4

       2 !NTHETA: angles
         1         2         3         2         3         4

       1 !NPHI: dihedrals
         1         2         3         4

       0 !NIMPHI: impropers


       0 !NDON: donors


       0 !NACC: acceptors


       0 !NNB

         0         0         0         0

       1       0 !NGRP
         0         0         0
"""

str = """
* Toppar stream file generated by
* CHARMM General Force Field (CGenFF) program version 1.0.0
* For use with CGenFF version 3.0.1
*

read rtf card append
* Topologies generated by
* CHARMM General Force Field (CGenFF) program version 1.0.0
*
36 1

! "penalty" is the highest penalty score of the associated parameters.
! Penalties lower than 10 indicate the analogy is fair; penalties between 10
! and 50 mean some basic validation is recommended; penalties higher than
! 50 indicate poor analogy and mandate extensive validation/optimization.

! Atom types added by Chaya D Stern so that this file is self contained.
! copied from top_all36_cgenff.rtf

MASS   318 CG321   12.01100  ! aliphatic C for CH2
MASS   322 CG331   12.01100  ! aliphatic C for methyl group (-CH3)

RESI TOY       0.000 ! param penalty=   0.000 ; charge penalty=   0.000
GROUP            ! CHARGE   CH_PENALTY
ATOM C1     CG331   0.0 !    0.000
ATOM C2     CG321   0.0 !    0.000
ATOM C3     CG321   0.0 !    0.000
ATOM C4     CG331   0.0 !    0.000

BOND C1   C2
BOND C3   C2
BOND C3   C4

END

read param card flex append
* Parameters generated by analogy by
* CHARMM General Force Field (CGenFF) program version 1.0.0
*

! Penalties lower than 10 indicate the analogy is fair; penalties between 10
! and 50 mean some basic validation is recommended; penalties higher than
! 50 indicate poor analogy and mandate extensive validation/optimization.

BONDS
CG321  CG321   222.50     1.5300 ! PROT alkane update, adm jr., 3/2/92
CG321  CG331   222.50     1.5280 ! PROT alkane update, adm jr., 3/2/92

ANGLES
CG321  CG321  CG331    58.00    115.00    8.00   2.56100 ! PROT alkane update, adm jr., 3/2/92

DIHEDRALS
CG331  CG321  CG321  CG331      0.0382  2     0.00 ! LIPID alkane, 4/04, jbk
CG331  CG321  CG321  CG331      0.0318  6   180.00 ! LIPID alkane, 4/04, jbk

IMPROPERS

END
RETURN
"""

class ToyModel(object):

    def __init__(self, true_value= 'random', initial_value = 'random'):
        self.param = CharmmParameterSet(StringIO(str))
        self.struct = CharmmPsfFile(StringIO(psf))
        self.pdb = app.PDBFile(StringIO(pdb))
        self.topology = md.load_psf(StringIO(psf))
        self.synthetic_energy = units.Quantity()
        self.positions = units.Quantity()
        self.platform = mm.Platform.getPlatformByName('Reference')

        # generate synthetic torsion scan
        self.torsion_scan(n_increments=, length=, theta=)

        # create torsionfit.TorsionScanSet
        torsions = np.zeros((len(self.positions), 4))
        torsions[:] = [1,2,3,4]
        direction = None
        steps = None
        self.scan_set = ScanSet.TorsionScanSet(self.positions.value_in_unit(units.nanometers), self.topology, self.struct,
                                  torsions, direction, steps, self.synthetic_energy.value_in_unit(units.kilojoules_per_mole))

        # create torsionfit.TorsionFitModel
        self.model = Model.TorsionFitModel(self.param, StringIO(str), self.scan_set, platform=self.platform, param_to_opt=[dih_type])


    def spher2cart(self, r, theta, phi):
        """convert spherical to cartesian corrdinates
        Paramters:
        r: bond length
        theta: bond angle
        phi: dihedral angle

        returns:
        cartesian coordinates
        """
        x = r * np.sin(theta) * np.cos(phi)
        y = r * np.sin(theta) * np.sin(phi)
        z = r * np.cos(theta)
        return [x, y, z]

    def torsion_scan(self, n_increments, length, theta):
        """
        Generate positions and energy for torsion scan
        Returns:

        """
        n_increments = n_increments
        n_atoms = 4
        phis = np.arange(-np.pi/2, +np.pi/2, (np.pi)/n_increments)
        positions = np.zeros((len(phis), n_atoms, 3))
        atom1_coords = self.spher2cart(length.value_in_unit(units.nanometer), theta.value_in_unit(units.radian), phis[0])
        for i, phi in enumerate(phis):
            atom3_coords = self.spher2cart(length.value_in_unit(units.nanometer), theta.value_in_unit(units.radian), phi)
            atom3_coords[-1] = abs(atom3_coords[-1]) + length._value
            positions[i] = [atom1_coords,
                [0.000, 0.000, 0.000],
                [0.000, 0.000, length._value],
                atom3_coords]
        self.positions = units.Quantity(value=positions, unit=units.nanometer) # put units back in

        # calculate energy
        self.synthetic_energy = units.Quantity(value=np.zeros((len(positions))), unit=units.kilojoules_per_mole)
        platform = mm.Platform.getPlatformByName('Reference')
        integrator = mm.VerletIntegrator(0.004*units.picoseconds)
        system = self.struct.createSystem()
        context = mm.Context(system, integrator, platform)
        for i, conf in enumerate(self.positions):
            context.setPositions(conf)
            state = context.getState(getEnergy=True)
            self.synthetic_energy[i] = state.getPotentialEnergy()




    def set_true_value(self):
        """
        Initialize values for torsion scan
        Returns:

        """

    def randomize_true_value(self):
        """

        Returns:

        """

    def randomize_initial_value(self):
